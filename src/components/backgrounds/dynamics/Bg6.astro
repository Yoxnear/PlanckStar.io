---
// 1 Instruction in this component

// Start here adjusting the number of particles (sparks). ‚ù∂
const sparkCount = 50;
---

<div id="spark-container" data-count={sparkCount} class="w-full h-80"></div>

<script>
import * as THREE from 'three';

const container = document.getElementById('spark-container');
const scene = new THREE.Scene();

const width = container.clientWidth;
const height = container.clientHeight;

const camera = new THREE.PerspectiveCamera(75, width / height, 0.1, 1000);
camera.position.z = 5;

const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
renderer.setSize(width, height);
renderer.setPixelRatio(window.devicePixelRatio);
container.appendChild(renderer.domElement);

const sparkCount = container.dataset.count;
const positions = new Float32Array(sparkCount * 3);
const offsets = new Float32Array(sparkCount);

const vFOV = camera.fov * Math.PI / 180;
const heightVisible = 2 * Math.tan(vFOV / 2) * camera.position.z;
const widthVisible = heightVisible * camera.aspect;

for (let i = 0; i < sparkCount; i++) {
  positions[i * 3] = (Math.random() - 0.5) * widthVisible;    
  positions[i * 3 + 1] = (Math.random() - 0.5) * heightVisible;
  positions[i * 3 + 2] = (Math.random() - 0.5) * 2.0;         
  offsets[i] = Math.random() * 100;                           
}

const geometry = new THREE.BufferGeometry();
geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
geometry.setAttribute('offset', new THREE.BufferAttribute(offsets, 1));

const vertexShader = `
  uniform float uTime;
  attribute float offset;
  varying float vAlpha;

  void main() {
    float sparkLife = sin(uTime * 2.0 + offset);
    vAlpha = max(sparkLife, 0.0);

    gl_PointSize = vAlpha * 6.0; 
    gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
  }
`;

const fragmentShader = `
  varying float vAlpha;

  void main() {
    vec2 uv = gl_PointCoord - vec2(0.5);
    float d = length(uv);
    if(d > 0.5) discard;

    vec3 color = vec3(1.0, 0.8, 0.8);
    gl_FragColor = vec4(color, vAlpha);
  }
`;

const material = new THREE.ShaderMaterial({
  uniforms: {
    uTime: { value: 0 }
  },
  vertexShader,
  fragmentShader,
  transparent: true,
  blending: THREE.AdditiveBlending,
  depthWrite: false
});

const sparks = new THREE.Points(geometry, material);
scene.add(sparks);

function animate() {
  requestAnimationFrame(animate);
  material.uniforms.uTime.value += 0.02;
  renderer.render(scene, camera);
}
animate();

window.addEventListener('resize', () => {
  const newWidth = container.clientWidth;
  const newHeight = container.clientHeight;
  renderer.setSize(newWidth, newHeight);
  camera.aspect = newWidth / newHeight;
  camera.updateProjectionMatrix();

  const vFOV = camera.fov * Math.PI / 180;
  const heightVisible = 2 * Math.tan(vFOV / 2) * camera.position.z;
  const widthVisible = heightVisible * camera.aspect;

  for (let i = 0; i < sparkCount; i++) {
    positions[i * 3] = (Math.random() - 0.5) * widthVisible;
    positions[i * 3 + 1] = (Math.random() - 0.5) * heightVisible;
  }
  geometry.attributes.position.needsUpdate = true;
});
</script>
