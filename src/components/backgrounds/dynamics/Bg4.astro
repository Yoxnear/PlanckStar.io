---
// 1 Instruction in this component
---

<div id="three-container4" class="w-full h-80">
</div>

<script>
    import * as THREE from 'three';

    const container = document.getElementById('three-container4');
    const scene = new THREE.Scene();

    const width = container.clientWidth;
    const height = container.clientHeight;

    const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

    const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
    renderer.setSize(width, height);
    renderer.setPixelRatio(window.devicePixelRatio);
    container.appendChild(renderer.domElement);

    const geometry = new THREE.PlaneGeometry(2, 2);

    const vertexShader = `
        varying vec2 vUv;
        void main() {
            vUv = uv;
            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
    `;

    // Here is where you can start adjusting the visual style. Play whit the values and colors. ❶ -----------------------|

    const fragmentShader = `
        uniform float uTime;
        uniform vec2 uResolution;
        uniform vec2 uMouse;
        varying vec2 vUv;

        // Simple random noise function
        float random(vec2 st) {
            return fract(sin(dot(st, vec2(12.9898, 78.233))) * 43758.5453123);
        }

        void main() {
            vec2 uv = vUv * uResolution / min(uResolution.x, uResolution.y);

            // Larger waves (lower frequency for a wider texture)
            float wave1 = sin(uv.x * 2.0 + uTime * 0.2) * cos(uv.y * 2.0 + uTime * 0.15) * 0.2;
            float wave2 = sin(uv.x * 1.0 - uTime * 0.3) * cos(uv.y * 1.0 - uTime * 0.2) * 0.15;

            // Combine waves
            float wave = wave1 + wave2;

            // Darker color palette
            vec3 baseColor = vec3(0.01, 0.02, 0.01); // Very dark blue
            vec3 accentColor = vec3(0.03, 0.05, 0.1); // Very dark purple
            vec3 glowColor = vec3(0.1, 0.1, 0.2); // Dark bluish glow

            // Gradient based on waves
            vec3 color = mix(baseColor, accentColor, wave * 0.5 + 0.5);

            // Glow effect with a larger interaction radius
            float distToMouse = distance(uv, uMouse * uResolution / min(uResolution.x, uResolution.y));
            float glow = exp(-distToMouse * 2.0) * 0.4; // Larger radius and stronger glow
            color += glowColor * glow * (sin(uTime * 1.2) * 0.2 + 0.8);

            // Bigger texture with less dense noise
            float noise = random(uv * 0.5 + uTime * 0.03) * 0.05; // Reduced scale for a larger texture
            color += vec3(noise);

            // Clamp colors to avoid exceeding 1.0
            color = clamp(color, 0.0, 1.0);

            gl_FragColor = vec4(color, 1.0);
        }
    `;

    const material = new THREE.ShaderMaterial({
        vertexShader,
        fragmentShader,
        uniforms: {
            uTime: { value: 0.0 },
            uResolution: { value: new THREE.Vector2(width, height) },
            uMouse: { value: new THREE.Vector2(0.5, 0.5) }
        }
    });

    const plane = new THREE.Mesh(geometry, material);
    scene.add(plane);

    function animate() {
        requestAnimationFrame(animate);
        material.uniforms.uTime.value += 0.05;
        renderer.render(scene, camera);
    }
    animate();

    container.addEventListener('mousemove', (event) => {
        const rect = container.getBoundingClientRect();
        material.uniforms.uMouse.value.set(
            (event.clientX - rect.left) / rect.width,
            1 - (event.clientY - rect.top) / rect.height
        );
    });

    window.addEventListener('resize', () => {
        const newWidth = container.clientWidth;
        const newHeight = container.clientHeight;
        renderer.setSize(newWidth, newHeight);
        material.uniforms.uResolution.value.set(newWidth, newHeight);
    });

</script>